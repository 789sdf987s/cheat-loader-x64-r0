#include <inc.h>
void watcher()
{
	VMProtectBeginVirtualization("wtcher_vr");
	while (1)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(250));
		if (VMProtectIsDebuggerPresent(1) || !VMProtectIsProtected() || VMProtectIsVirtualMachinePresent() || IsDebuggerPresent() || !VMProtectIsValidImageCRC()) { user::p_data->log(stra("user is running a debugger!")); ExitProcess(0); }
		anti::p_opcode->work();
		anti::p_proc->work();
	}
	VMProtectEnd();
}

/*
needed 
https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads
*/

void thread()
{
	SetConsoleTitleA(" ");
	print("loading");
	user::p_data = new user::c_data();
	if (!user::p_data->setup()) { ExitProcess(0); }
	driver::p_loader = new driver::c_loader();
	driver::p_exploit = new driver::c_exploit();
	game::p_game = new game::c_game();
	anti::p_proc = new anti::c_proc();
	anti::p_opcode = new anti::c_opcode();
	if (game::p_game->running()) { user::p_data->log(stra("game already running forcing exit"), 1); ExitProcess(0); }
	anti::p_opcode->setup();
	anti::p_opcode->add((void*)thread, 0, 1, stra("mn"));
	anti::p_opcode->add((void*)DeleteFileA, 0, 1, stra("delfilea"));
	anti::p_opcode->add((void*)IsDebuggerPresent, 0, 1, stra("isdeb"));
	anti::p_opcode->add((void*)watcher, 0, 1, stra("wathrd"));
	anti::p_opcode->add((void*)LoadLibraryA, 0, 1, stra("llib"));
	anti::p_opcode->add((void*)VirtualProtectEx, 0, 1, stra("vproex"));
	anti::p_opcode->add((void*)OpenProcess, 0, 1, stra("openpr"));
	anti::p_opcode->add((void*)ExitProcess, 0, 1, stra("expro"));
	anti::p_opcode->add((void*)CreateThread, 0, 1, stra("cthrd"));
	auto hnd = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)watcher, 0, 0, 0);
	anti::p_proc->stealththrd(hnd);
	auto client = new web::client(true, true);
	srand((int)&client + time(NULL));
	if (!client->connect(strw(L"back.something.com"))) { ExitProcess(0); }
	/*look if user has never logged in before*/
	if (user::p_data->name().empty())
	{
		auto tmp = std::string();
		print(std::string("confirmation key: ").append(user::p_data->hwid_get().c_str()).c_str());
		std::cout << stra("([]) user:"); std::cin >> tmp;
		if (tmp.empty()) ExitProcess(0); user::p_data->set_name(tmp); tmp.clear();
		std::cout << stra("([]) pass:"); std::cin >> tmp;
		if (tmp.empty()) ExitProcess(0); user::p_data->set_pass(tmp); tmp.clear();
		user::p_data->save(); user::p_data->log(stra(std::string("---").c_str())); user::p_data->log(stra(std::string("new session started").c_str()));  user::p_data->log(stra(std::string("user saved details u:").append(user::p_data->name()).append(" p:").append(user::p_data->pass()).append(" h:").append(user::p_data->hwid()).append(" h:").append(user::p_data->hwid_get()).append(" v:").append(ver).c_str()));
	}
	else
	{
		user::p_data->log(stra(std::string("---").c_str()));
		user::p_data->log(stra(std::string("new session started").c_str()));
	}
	/*login and checking*/
	if (!client->request(strw(L"gate_z.php"), web::requestmode::GET, { { stra("user"), user::p_data->name() }, { stra("pass"), user::p_data->pass() }, { stra("hwid"), user::p_data->hwid() }, { stra("ver"), ver } })) { ExitProcess(0); }
	user::p_data->log(stra(std::string("user attempting auth u:").append(user::p_data->name()).append(" p:").append(user::p_data->pass()).append(" h:").append(user::p_data->hwid()).append(" h:").append(user::p_data->hwid_get()).append(" v:").append(ver).c_str()));
	auto res = client->tostring(client->get());
	if (std::strstr(res.c_str(), stra("wrong")))
	{
		auto err = res.find("0");
		auto nstr = res.erase(0, err);
		print(std::string("auth returned ").append(nstr).c_str());
		user::p_data->log(stra(std::string("user failed auth reason ").append(nstr).c_str()), 1);
		auto a = getchar(); ExitProcess(0);
	}
	if (res.empty()) { ExitProcess(0); } user::p_data->set_encr(res); user::p_data->log(stra(std::string("user auth competed rk:").append(std::to_string(user::p_data->encr())).c_str()));

	auto service_name = user::p_data->rstr(15);
	auto driver_name = service_name; driver_name.append(stra(".sys"));
	auto driver_path = std::string(stra("C:\\Windows\\System32\\drivers\\"));
	driver_path.append(driver_name);

	auto zero_service_name = user::p_data->rstr(12);
	auto zero_driver_name = zero_service_name; zero_driver_name.append(stra(".sys"));
	auto zero_driver_path = std::string(stra("C:\\Windows\\System32\\drivers\\"));
	zero_driver_path.append(zero_driver_name);

	user::p_data->log(stra(std::string("pseudo names generated byp:").append(driver_name).append(" core:").append(zero_driver_name).c_str()));

	system(stra("sc stop SmrtService >NULL")); Sleep(200); DeleteFileA(stra("NULL"));

	/*downloading and unpacking the cheat itself*/
	user::p_data->log(stra("user requesting image_z"));
	if (!client->request(strw(L"image_z.php"), web::requestmode::GET, { {stra("user"),user::p_data->name()}, {stra("pass"),user::p_data->pass()}, {stra("hwid"),user::p_data->hwid()}, {stra("ver"),ver} })) { ExitProcess(0); }
	auto image_z = client->get();
	user::p_data->log(stra(std::string("user recieved image_z with size ").append(std::to_string(image_z.size())).c_str()));

	std::thread f_dec_worker([&image_z] { auto key = user::p_data->encr(); for (auto c = 0; c < image_z.size(); c++) { image_z[c] -= 1; image_z[c] ^= key; } });
	f_dec_worker.join();/*wait for exec to finish*/
	user::p_data->log(stra(std::string("user unpacked image_z with size ").append(std::to_string(image_z.size())).c_str()));

	/*~~~~~~~~~~~~*/

	/*downloading and unpacking the ac bypass driver*/
	user::p_data->log(stra("user requesting image_z_drv"));
	if (!client->request(strw(L"image_z_drv_test.php"), web::requestmode::GET, { {stra("user"),user::p_data->name()}, {stra("pass"),user::p_data->pass()}, {stra("hwid"),user::p_data->hwid()}, {stra("ver"),ver} })) { ExitProcess(0); }
	auto image_z_drv = client->get();
	user::p_data->log(stra(std::string("user recieved image_z_drv with size ").append(std::to_string(image_z_drv.size())).c_str()));

	std::thread f_dec_worker_drv([&image_z_drv] { auto key = user::p_data->encr(); for (auto c = 0; c < image_z_drv.size(); c++) { image_z_drv[c] -= 1; image_z_drv[c] ^= key; } });
	f_dec_worker_drv.join();/*wait for exec to finish*/
	user::p_data->log(stra(std::string("user unpacked image_z_drv with size ").append(std::to_string(image_z_drv.size())).c_str()));
	user::p_data->log(stra("loading completed"));

	/*loading the exploit driver - activating*/
	std::wstring service_name_wstr(service_name.begin(), service_name.end());
	driver::p_loader->setup(driver_name);
	if (!driver::p_loader->load(service_name_wstr)) { user::p_data->log(stra("user failed to load byp driver"), 1); DeleteFileA(driver_path.c_str()); ExitProcess(0); }
	driver::p_exploit->exploit(0, driver::p_exploit->cioption());
	driver::p_loader->unload(service_name_wstr.c_str());	
	DeleteFileA(driver_path.c_str());

	Sleep(750);

	/*loading the cheat driver*/
	std::ofstream core_out(zero_driver_path, std::ios::binary);
	core_out << client->tostring(image_z_drv); core_out.close();
	std::wstring zero_service_name_wstr(zero_service_name.begin(), zero_service_name.end());
	if (!driver::p_loader->load(zero_service_name_wstr)) { user::p_data->log(stra("user failed to load core driver"), 1); DeleteFileA(zero_driver_path.c_str()); ExitProcess(0); }

	/*unexploit*/
	driver::p_loader->setup(driver_name);
	if (!driver::p_loader->load(service_name_wstr)) { user::p_data->log(stra("user failed to load byp driver"), 1); DeleteFileA(driver_path.c_str()); ExitProcess(0); }
	driver::p_exploit->exploit(1, driver::p_exploit->cioption());
	driver::p_loader->unload(service_name_wstr.c_str());	
	DeleteFileA(driver_path.c_str());

	print("waiting for <game>");
	user::p_data->log(stra("waiting for game"));

	while (!game::p_game->running()) { Sleep(500); }

	print("<game> detected");
	user::p_data->log(stra("game found"));
	user::p_data->flag(); /*allows the cheat to load ingame*/

	/*injection*/
	if (!game::p_game->inject(image_z))
	{
		print("error while loading");
		user::p_data->log("error while writing image", 1);
	}

	/*unloading core driver procedure*/
	driver::p_loader->unload(zero_service_name_wstr.c_str());
	DeleteFileA(zero_driver_path.c_str());	

	user::p_data->log(stra("finished"));
	Beep(200, 100);

	ExitProcess(0);
}

int main()
{
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)thread, 0, 0, 0);
	while (1){}
}
